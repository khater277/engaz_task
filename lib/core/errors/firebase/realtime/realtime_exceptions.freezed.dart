// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'realtime_exceptions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$RealtimeExceptionHandler {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RealtimeExceptionHandlerCopyWith<$Res> {
  factory $RealtimeExceptionHandlerCopyWith(RealtimeExceptionHandler value,
          $Res Function(RealtimeExceptionHandler) then) =
      _$RealtimeExceptionHandlerCopyWithImpl<$Res, RealtimeExceptionHandler>;
}

/// @nodoc
class _$RealtimeExceptionHandlerCopyWithImpl<$Res,
        $Val extends RealtimeExceptionHandler>
    implements $RealtimeExceptionHandlerCopyWith<$Res> {
  _$RealtimeExceptionHandlerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DisconnectedImplCopyWith<$Res> {
  factory _$$DisconnectedImplCopyWith(
          _$DisconnectedImpl value, $Res Function(_$DisconnectedImpl) then) =
      __$$DisconnectedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DisconnectedImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$DisconnectedImpl>
    implements _$$DisconnectedImplCopyWith<$Res> {
  __$$DisconnectedImplCopyWithImpl(
      _$DisconnectedImpl _value, $Res Function(_$DisconnectedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DisconnectedImpl implements Disconnected {
  const _$DisconnectedImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.disconnected()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DisconnectedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return disconnected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return disconnected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (disconnected != null) {
      return disconnected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return disconnected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return disconnected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (disconnected != null) {
      return disconnected(this);
    }
    return orElse();
  }
}

abstract class Disconnected implements RealtimeExceptionHandler {
  const factory Disconnected() = _$DisconnectedImpl;
}

/// @nodoc
abstract class _$$ExpiredTokenImplCopyWith<$Res> {
  factory _$$ExpiredTokenImplCopyWith(
          _$ExpiredTokenImpl value, $Res Function(_$ExpiredTokenImpl) then) =
      __$$ExpiredTokenImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ExpiredTokenImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$ExpiredTokenImpl>
    implements _$$ExpiredTokenImplCopyWith<$Res> {
  __$$ExpiredTokenImplCopyWithImpl(
      _$ExpiredTokenImpl _value, $Res Function(_$ExpiredTokenImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ExpiredTokenImpl implements ExpiredToken {
  const _$ExpiredTokenImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.expiredToken()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ExpiredTokenImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return expiredToken();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return expiredToken?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (expiredToken != null) {
      return expiredToken();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return expiredToken(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return expiredToken?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (expiredToken != null) {
      return expiredToken(this);
    }
    return orElse();
  }
}

abstract class ExpiredToken implements RealtimeExceptionHandler {
  const factory ExpiredToken() = _$ExpiredTokenImpl;
}

/// @nodoc
abstract class _$$InvalidTokenImplCopyWith<$Res> {
  factory _$$InvalidTokenImplCopyWith(
          _$InvalidTokenImpl value, $Res Function(_$InvalidTokenImpl) then) =
      __$$InvalidTokenImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidTokenImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$InvalidTokenImpl>
    implements _$$InvalidTokenImplCopyWith<$Res> {
  __$$InvalidTokenImplCopyWithImpl(
      _$InvalidTokenImpl _value, $Res Function(_$InvalidTokenImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidTokenImpl implements InvalidToken {
  const _$InvalidTokenImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.invalidToken()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InvalidTokenImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return invalidToken();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return invalidToken?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (invalidToken != null) {
      return invalidToken();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return invalidToken(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return invalidToken?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (invalidToken != null) {
      return invalidToken(this);
    }
    return orElse();
  }
}

abstract class InvalidToken implements RealtimeExceptionHandler {
  const factory InvalidToken() = _$InvalidTokenImpl;
}

/// @nodoc
abstract class _$$MaxRetriesImplCopyWith<$Res> {
  factory _$$MaxRetriesImplCopyWith(
          _$MaxRetriesImpl value, $Res Function(_$MaxRetriesImpl) then) =
      __$$MaxRetriesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MaxRetriesImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$MaxRetriesImpl>
    implements _$$MaxRetriesImplCopyWith<$Res> {
  __$$MaxRetriesImplCopyWithImpl(
      _$MaxRetriesImpl _value, $Res Function(_$MaxRetriesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MaxRetriesImpl implements MaxRetries {
  const _$MaxRetriesImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.maxRetries()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MaxRetriesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return maxRetries();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return maxRetries?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (maxRetries != null) {
      return maxRetries();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return maxRetries(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return maxRetries?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (maxRetries != null) {
      return maxRetries(this);
    }
    return orElse();
  }
}

abstract class MaxRetries implements RealtimeExceptionHandler {
  const factory MaxRetries() = _$MaxRetriesImpl;
}

/// @nodoc
abstract class _$$NetworkErrorImplCopyWith<$Res> {
  factory _$$NetworkErrorImplCopyWith(
          _$NetworkErrorImpl value, $Res Function(_$NetworkErrorImpl) then) =
      __$$NetworkErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NetworkErrorImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$NetworkErrorImpl>
    implements _$$NetworkErrorImplCopyWith<$Res> {
  __$$NetworkErrorImplCopyWithImpl(
      _$NetworkErrorImpl _value, $Res Function(_$NetworkErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NetworkErrorImpl implements NetworkError {
  const _$NetworkErrorImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.networkError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NetworkErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return networkError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return networkError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return networkError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return networkError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (networkError != null) {
      return networkError(this);
    }
    return orElse();
  }
}

abstract class NetworkError implements RealtimeExceptionHandler {
  const factory NetworkError() = _$NetworkErrorImpl;
}

/// @nodoc
abstract class _$$OperationFailedImplCopyWith<$Res> {
  factory _$$OperationFailedImplCopyWith(_$OperationFailedImpl value,
          $Res Function(_$OperationFailedImpl) then) =
      __$$OperationFailedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OperationFailedImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$OperationFailedImpl>
    implements _$$OperationFailedImplCopyWith<$Res> {
  __$$OperationFailedImplCopyWithImpl(
      _$OperationFailedImpl _value, $Res Function(_$OperationFailedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OperationFailedImpl implements OperationFailed {
  const _$OperationFailedImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.operationFailed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OperationFailedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return operationFailed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return operationFailed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (operationFailed != null) {
      return operationFailed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return operationFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return operationFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (operationFailed != null) {
      return operationFailed(this);
    }
    return orElse();
  }
}

abstract class OperationFailed implements RealtimeExceptionHandler {
  const factory OperationFailed() = _$OperationFailedImpl;
}

/// @nodoc
abstract class _$$OverriddenBySetImplCopyWith<$Res> {
  factory _$$OverriddenBySetImplCopyWith(_$OverriddenBySetImpl value,
          $Res Function(_$OverriddenBySetImpl) then) =
      __$$OverriddenBySetImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OverriddenBySetImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$OverriddenBySetImpl>
    implements _$$OverriddenBySetImplCopyWith<$Res> {
  __$$OverriddenBySetImplCopyWithImpl(
      _$OverriddenBySetImpl _value, $Res Function(_$OverriddenBySetImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OverriddenBySetImpl implements OverriddenBySet {
  const _$OverriddenBySetImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.overriddenBySet()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OverriddenBySetImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return overriddenBySet();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return overriddenBySet?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (overriddenBySet != null) {
      return overriddenBySet();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return overriddenBySet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return overriddenBySet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (overriddenBySet != null) {
      return overriddenBySet(this);
    }
    return orElse();
  }
}

abstract class OverriddenBySet implements RealtimeExceptionHandler {
  const factory OverriddenBySet() = _$OverriddenBySetImpl;
}

/// @nodoc
abstract class _$$PermissionDeniedImplCopyWith<$Res> {
  factory _$$PermissionDeniedImplCopyWith(_$PermissionDeniedImpl value,
          $Res Function(_$PermissionDeniedImpl) then) =
      __$$PermissionDeniedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PermissionDeniedImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$PermissionDeniedImpl>
    implements _$$PermissionDeniedImplCopyWith<$Res> {
  __$$PermissionDeniedImplCopyWithImpl(_$PermissionDeniedImpl _value,
      $Res Function(_$PermissionDeniedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PermissionDeniedImpl implements PermissionDenied {
  const _$PermissionDeniedImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.permissionDenied()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PermissionDeniedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return permissionDenied();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return permissionDenied?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (permissionDenied != null) {
      return permissionDenied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return permissionDenied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return permissionDenied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (permissionDenied != null) {
      return permissionDenied(this);
    }
    return orElse();
  }
}

abstract class PermissionDenied implements RealtimeExceptionHandler {
  const factory PermissionDenied() = _$PermissionDeniedImpl;
}

/// @nodoc
abstract class _$$UnavailableImplCopyWith<$Res> {
  factory _$$UnavailableImplCopyWith(
          _$UnavailableImpl value, $Res Function(_$UnavailableImpl) then) =
      __$$UnavailableImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnavailableImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$UnavailableImpl>
    implements _$$UnavailableImplCopyWith<$Res> {
  __$$UnavailableImplCopyWithImpl(
      _$UnavailableImpl _value, $Res Function(_$UnavailableImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UnavailableImpl implements Unavailable {
  const _$UnavailableImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.unavailable()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnavailableImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return unavailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return unavailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (unavailable != null) {
      return unavailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return unavailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return unavailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (unavailable != null) {
      return unavailable(this);
    }
    return orElse();
  }
}

abstract class Unavailable implements RealtimeExceptionHandler {
  const factory Unavailable() = _$UnavailableImpl;
}

/// @nodoc
abstract class _$$UnknownErrorImplCopyWith<$Res> {
  factory _$$UnknownErrorImplCopyWith(
          _$UnknownErrorImpl value, $Res Function(_$UnknownErrorImpl) then) =
      __$$UnknownErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownErrorImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$UnknownErrorImpl>
    implements _$$UnknownErrorImplCopyWith<$Res> {
  __$$UnknownErrorImplCopyWithImpl(
      _$UnknownErrorImpl _value, $Res Function(_$UnknownErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UnknownErrorImpl implements UnknownError {
  const _$UnknownErrorImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.unknownError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnknownErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return unknownError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return unknownError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (unknownError != null) {
      return unknownError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return unknownError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return unknownError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (unknownError != null) {
      return unknownError(this);
    }
    return orElse();
  }
}

abstract class UnknownError implements RealtimeExceptionHandler {
  const factory UnknownError() = _$UnknownErrorImpl;
}

/// @nodoc
abstract class _$$UserCodeExceptionImplCopyWith<$Res> {
  factory _$$UserCodeExceptionImplCopyWith(_$UserCodeExceptionImpl value,
          $Res Function(_$UserCodeExceptionImpl) then) =
      __$$UserCodeExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserCodeExceptionImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res,
        _$UserCodeExceptionImpl>
    implements _$$UserCodeExceptionImplCopyWith<$Res> {
  __$$UserCodeExceptionImplCopyWithImpl(_$UserCodeExceptionImpl _value,
      $Res Function(_$UserCodeExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserCodeExceptionImpl implements UserCodeException {
  const _$UserCodeExceptionImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.userCodeException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserCodeExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return userCodeException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return userCodeException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (userCodeException != null) {
      return userCodeException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return userCodeException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return userCodeException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (userCodeException != null) {
      return userCodeException(this);
    }
    return orElse();
  }
}

abstract class UserCodeException implements RealtimeExceptionHandler {
  const factory UserCodeException() = _$UserCodeExceptionImpl;
}

/// @nodoc
abstract class _$$WriteCanceledImplCopyWith<$Res> {
  factory _$$WriteCanceledImplCopyWith(
          _$WriteCanceledImpl value, $Res Function(_$WriteCanceledImpl) then) =
      __$$WriteCanceledImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WriteCanceledImplCopyWithImpl<$Res>
    extends _$RealtimeExceptionHandlerCopyWithImpl<$Res, _$WriteCanceledImpl>
    implements _$$WriteCanceledImplCopyWith<$Res> {
  __$$WriteCanceledImplCopyWithImpl(
      _$WriteCanceledImpl _value, $Res Function(_$WriteCanceledImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WriteCanceledImpl implements WriteCanceled {
  const _$WriteCanceledImpl();

  @override
  String toString() {
    return 'RealtimeExceptionHandler.writeCanceled()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WriteCanceledImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disconnected,
    required TResult Function() expiredToken,
    required TResult Function() invalidToken,
    required TResult Function() maxRetries,
    required TResult Function() networkError,
    required TResult Function() operationFailed,
    required TResult Function() overriddenBySet,
    required TResult Function() permissionDenied,
    required TResult Function() unavailable,
    required TResult Function() unknownError,
    required TResult Function() userCodeException,
    required TResult Function() writeCanceled,
  }) {
    return writeCanceled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? disconnected,
    TResult? Function()? expiredToken,
    TResult? Function()? invalidToken,
    TResult? Function()? maxRetries,
    TResult? Function()? networkError,
    TResult? Function()? operationFailed,
    TResult? Function()? overriddenBySet,
    TResult? Function()? permissionDenied,
    TResult? Function()? unavailable,
    TResult? Function()? unknownError,
    TResult? Function()? userCodeException,
    TResult? Function()? writeCanceled,
  }) {
    return writeCanceled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disconnected,
    TResult Function()? expiredToken,
    TResult Function()? invalidToken,
    TResult Function()? maxRetries,
    TResult Function()? networkError,
    TResult Function()? operationFailed,
    TResult Function()? overriddenBySet,
    TResult Function()? permissionDenied,
    TResult Function()? unavailable,
    TResult Function()? unknownError,
    TResult Function()? userCodeException,
    TResult Function()? writeCanceled,
    required TResult orElse(),
  }) {
    if (writeCanceled != null) {
      return writeCanceled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Disconnected value) disconnected,
    required TResult Function(ExpiredToken value) expiredToken,
    required TResult Function(InvalidToken value) invalidToken,
    required TResult Function(MaxRetries value) maxRetries,
    required TResult Function(NetworkError value) networkError,
    required TResult Function(OperationFailed value) operationFailed,
    required TResult Function(OverriddenBySet value) overriddenBySet,
    required TResult Function(PermissionDenied value) permissionDenied,
    required TResult Function(Unavailable value) unavailable,
    required TResult Function(UnknownError value) unknownError,
    required TResult Function(UserCodeException value) userCodeException,
    required TResult Function(WriteCanceled value) writeCanceled,
  }) {
    return writeCanceled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Disconnected value)? disconnected,
    TResult? Function(ExpiredToken value)? expiredToken,
    TResult? Function(InvalidToken value)? invalidToken,
    TResult? Function(MaxRetries value)? maxRetries,
    TResult? Function(NetworkError value)? networkError,
    TResult? Function(OperationFailed value)? operationFailed,
    TResult? Function(OverriddenBySet value)? overriddenBySet,
    TResult? Function(PermissionDenied value)? permissionDenied,
    TResult? Function(Unavailable value)? unavailable,
    TResult? Function(UnknownError value)? unknownError,
    TResult? Function(UserCodeException value)? userCodeException,
    TResult? Function(WriteCanceled value)? writeCanceled,
  }) {
    return writeCanceled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Disconnected value)? disconnected,
    TResult Function(ExpiredToken value)? expiredToken,
    TResult Function(InvalidToken value)? invalidToken,
    TResult Function(MaxRetries value)? maxRetries,
    TResult Function(NetworkError value)? networkError,
    TResult Function(OperationFailed value)? operationFailed,
    TResult Function(OverriddenBySet value)? overriddenBySet,
    TResult Function(PermissionDenied value)? permissionDenied,
    TResult Function(Unavailable value)? unavailable,
    TResult Function(UnknownError value)? unknownError,
    TResult Function(UserCodeException value)? userCodeException,
    TResult Function(WriteCanceled value)? writeCanceled,
    required TResult orElse(),
  }) {
    if (writeCanceled != null) {
      return writeCanceled(this);
    }
    return orElse();
  }
}

abstract class WriteCanceled implements RealtimeExceptionHandler {
  const factory WriteCanceled() = _$WriteCanceledImpl;
}
